# Load Libraries
import pandas as pd
import numpy as np
import json
import streamlit as st
from streamlit_searchbox import st_searchbox
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from typing import Optional, Dict, Tuple, List, Union

st.set_page_config(
    page_title="Track Recommendation",
    page_icon="💁‍♀️",
)

# Import data_galaxy after Page Config
from data_galaxy import init_spotify_client

class TrackRecommendation:
    def __init__(self, sp) -> None:
        self.sp = sp

    def get_track_id(self, artist_name: str, track_name: str) -> Optional[str]:
        """
        Search for a track by artist and track name, and return the Spotify track ID.
        Args:
          artist_name (str): The name of the artist.
          track_name (str): The name of the track.
        Returns:
          Optional[str]: The Spotify ID of the track, or None if not found.
        """
        query = f"artist:{artist_name} track:{track_name}"
        results = self.sp.search(q=query, type='track', limit=1)
        
        # Check if there are any tracks in the results
        items = results['tracks']['items']
        if items:
            # Return the first track's ID
            return items[0]['id']
        else:
            # Return None if no tracks were found
            return None
        
    def find_similar_tracks(self, target_track_id: str, selected_artist:str) -> List[Dict[str, Optional[Union[str,float]]]]:
        """ 
         Find similar tracks to the target track based on Recommendation generated by API
         Args:
           target_track_id (str)
           access_token (str)
         Returns:
           list of dictionaries containing similar tracks information
           """

        # Get recommendations based on target track id
        results = self.sp.recommendations(seed_tracks=[target_track_id], limit=10)
        #print(f'Recom Results: {results}')

        # Extract information from result
        similar_tracks = []
        for track in results['tracks']:
            # Check if any of the artists match the input artist name
            if any(artist['name'].lower() == selected_artist.lower() for artist in track['artists']):
                continue
            # Ensuring the target track is not included in the list of recommendations
            if track['id'] != target_track_id:
                audio_features = self.sp.audio_features(track['id'])[0]
                popularity = track.get('popularity', None)

                similar_tracks.append({
                    'name': track['name'],
                    'artist': track['artists'][0]['name'],
                    'id': track['id'],
                    'popularity': popularity,
                    'audio_features': audio_features
                })

        return similar_tracks

# Spotify Client Outh Initialization & Instantiation
sp = init_spotify_client()
track_recommendation = TrackRecommendation(sp)

###### Search Functions for Autocomplete Features ######
def artist_search_func(sp,query) -> List[str]:
    result = sp.search(q=query, type='artist', limit=5)
    artists = [artist['name'] for artist in result['artists']['items']]
    return artists
    
def artist_track_search_func(sp, artist, query) -> List[str]:
    result = sp.search(q=f"artist:{artist} track:{query}", type='track', limit=10)
    tracks = [track['name'] for track in result['tracks']['items']]
    return tracks

# Sidebar 
with st.sidebar:
    st.title("Enter Your Track")
    # Artist input
    selected_artist = st_searchbox(label="Select Artist", 
                                   key="artist_input", 
                                   search_function=lambda query: artist_search_func(sp, query))
    # Track input
    selected_track = st_searchbox(label="Select Track", 
                                  key="track_input", 
                                  search_function=lambda query: artist_track_search_func(sp, selected_artist, query))
    # Compare button
    analyze_button = st.sidebar.button("Analyze")

#--------- Main -----------
st.markdown("# Track Recommendation")
st.info("Select an artist and track name. You'll get a list of recommended tracks based on the track of your choice!", icon="✨")

try:
    if analyze_button:
        track_id = track_recommendation.get_track_id(selected_artist, selected_track)
        if track_id:
            # Fetch track details
            track_details = sp.track(track_id)
            track_popularity = track_details['popularity']
            track_name = track_details['name']

            # User's Track Player
            st.header(f'{track_name}')
            st.subheader(f'Popularity: {track_popularity}')
            st.components.v1.iframe(f"https://open.spotify.com/embed/track/{track_id}?utm_source=generator",
                                                width=500, height=160, scrolling=True)
            st.divider()

            similar_tracks = track_recommendation.find_similar_tracks(track_id, selected_artist)
            st.header('Similar Tracks:')
            for idx, track in enumerate(similar_tracks, start=1):
                ids = track['id']
                st.write(f"{idx}. **{track['name']}** by **{track['artist']}** | Popularity: **{track['popularity']}**")
                # Load URL component for each recommendation tracks
                st.components.v1.iframe(f"https://open.spotify.com/embed/track/{ids}?utm_source=generator",
                                        width=500, height=160, scrolling=True)
        else:
            st.error("No Similar Tracks Found.")
except Exception as e:
    print(e)
    st.error("An error occurred during analysis. Please try again.")
